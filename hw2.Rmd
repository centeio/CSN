---
title: "R Notebook"
output: html_notebook
---

```{r}
require(stats4)
require(VGAM)
```


```{r Functions}
#FUNCTIONS

# get the -2LogLikelihood of a function
get_2LL = function(x){
  attributes(summary(x))$m2logL
}

# get the MLE of a parameter
get_estimate = function(x,i){
  attributes(summary(x))$coef[i]
}

# C constant of displaced Poisson
logf <- function(i){
  sum(log(seq(1, i)))
}

# MINUS LOG-LIKELIHOOD OF CANDIDATE DISTRIBUTIONS

# minus log-likelihood of the displaced poisson function
minus_log_likelihood_poiss = function(lambda){
  -(M*log(lambda)
  -N*(lambda+log(1-exp(-lambda)))
  -C)
}

# minus log-likelihood of displaced geometric distribution
minus_log_likelihood_geom <- function(q){
  -N*log(q)-(M-N)*log(1-q)
}

# minus log-likelihood of zeta distribution with fixed exponent (2)
minus_log_likelihood_zeta2 = function() {
  2*sum(log(x))
  +length(x)*log(pi^2/6)
}

# minus log-likelihood of zeta function
minus_log_likelihood_zeta <- function(gamma) {
  length(x) * log(zeta(gamma)) + gamma * sum(log(x))
}

# hmax function - harmonic number function
hmax = function(kmax, gamma){
  k_list = seq(1,kmax)
  out = sum(k_list^(-gamma))
  return(out)
}

# minus log-likelihood of zeta right truncated function
minus_log_likelihood_rt_zeta <- function(gamma, kmax) {
  gamma*sum(log(x)) + length(x)*hmax(kmax, gamma)
}

# AIC EVALUATION
# function to compute the Akaike Information Criterion
get_AIC <- function(m2logL,K,N) {
  a = m2logL + 2*K*N/(N-K-1)# AIC with a correction for sample size
  return(a)
}

# ALTMANN Log-Likelihood FUNCTION

altmann_ll = function(gamma_alt, delta){
  csum = 0
  for(i in 1:length(x)){
    csum = csum + (i^(-gamma_alt))*(exp(-delta*i))
  }
  c = 1/csum
  
  
  result = 0
  for(i in 1:length(x)){
    result = result - (log(c) + (-gamma_alt)*log(x[i]) + (-delta*x[i]))
  }
  
  return(result)

}
```

```{r}
languages = list.files(path = "./data/", pattern = "*.txt", full.names = TRUE)
```


```{r}
# number of parameters for each distribution(poisson, geometric, zeta, rt zeta)
K = c(1,1,1,2,2)
params_vector = matrix(data = NA, nrow = length(languages), ncol = length(K)+2)
AIC_vect      = matrix(data = NA, nrow = length(languages), ncol = length(K))
AIC_delta     = matrix(data = NA, nrow = length(languages), ncol = length(K)-1)
new_AIC_delta = matrix(data = NA, nrow = length(languages), ncol = length(K))

colnames(params_vector) = c("lambda", "q", "gamma_zeta", "gamma rt zeta", "kmax", "gamma", "delta")
colnames(AIC_vect)      = c("POISSON", "GEO", "ZETA", "RT ZETA", "ALTMANN")
colnames(AIC_delta)     = c("POISSON", "GEO", "ZETA", "RT ZETA")
colnames(new_AIC_delta)     = c("POISSON", "GEO", "ZETA", "RT ZETA", "ALTMANN")

rownames(params_vector) = c("Arabic", "Basque", "Catalan", "Chinese", "Czech", 
                            "English", "Greek", "Hungarian", "Italian", "Turkish")
rownames(AIC_vect) = c("Arabic", "Basque", "Catalan", "Chinese", "Czech", 
                       "English", "Greek", "Hungarian", "Italian", "Turkish")
rownames(AIC_delta) = c("Arabic", "Basque", "Catalan", "Chinese", "Czech", 
                        "English", "Greek", "Hungarian", "Italian", "Turkish")
rownames(new_AIC_delta) = c("Arabic", "Basque", "Catalan", "Chinese", "Czech", 
                        "English", "Greek", "Hungarian", "Italian", "Turkish")

```

```{r}
for(i in 1:length(languages)){
  degree_sequence = read.delim(languages[i], header = FALSE)
  x = degree_sequence$V1
  
  # hyperparameters of interest
  M = sum(x)
  M_prime = sum(log(x))
  N = length(x)
  C = 0
  for(j in 1:length(x)){
    C = C+logf(x[j])
  }
  lower_k = max(x)
  
  #MLE POISSON
  mle_pois <- mle(minus_log_likelihood_poiss,
            start = list(lambda = M/N),
            method = "L-BFGS-B",
            lower = c(1.0000001))
  
  # MLE GEOM
  mle_geom <- mle(minus_log_likelihood_geom,
                  start = list(q=N/M),
                  method = "L-BFGS-B",
                  lower = c(0.0000001),
                  upper = c(0.9999999))
  
  # MLE ZETA
  mle_zeta <- mle(minus_log_likelihood_zeta,
                  start = list(gamma = 2),
                  method = "L-BFGS-B",
                  lower = c(1.0000001))
  
  # MLE RT ZETA
  gamma_opt = mle(minus_log_likelihood_rt_zeta,
                  start = list(gamma = 1.00001),
                  fixed = list(kmax = lower_k),
                  method = "L-BFGS-B",
                  lower = c(1.00001))
  
  mle_zeta_rt = mle(minus_log_likelihood_rt_zeta,
                    start = list(kmax = lower_k),
                    fixed = list(gamma = get_estimate(gamma_opt,1)),
                    method = "L-BFGS-B",
                    lower = c(lower_k))
  
  
  #MLE Altmann
  mle_altmann = mle(altmann_ll,
        start = list(gamma_alt=1.001, delta = 0.001),
        method = "L-BFGS-B",
        lower = c(1.0000001, 0.0000001))
  
  params_vector[i,] = c(get_estimate(mle_pois,1),
                        get_estimate(mle_geom,1), 
                        get_estimate(mle_zeta,1), 
                        get_estimate(gamma_opt,1),
                        get_estimate(mle_zeta_rt,1),
                        get_estimate(mle_altmann,1),
                        get_estimate(mle_altmann,2))
  
  # -2logLikelihood of each function
  ll_pois = get_2LL(mle_pois)
  ll_geom = get_2LL(mle_geom)
  ll_zeta = get_2LL(mle_zeta)
  ll_rtz  = get_2LL(mle_zeta_rt)
  ll_altmann = get_2LL(mle_altmann)
  
  # -2logL
  L = c(ll_pois, ll_geom, ll_zeta, ll_rtz, ll_altmann)
  
  # AIC value for each distribution
  for (z in 1:length(K)){
    AIC_vect[i,z] = get_AIC(L[z], K[z], N )
  }
  

  # best AIC value
  best = min(AIC_vect[i,1:(length(K)-1)])
  best2 = min(AIC_vect[i,])
  
  # evaluating the delta AIC
  AIC_delta[i,] = AIC_vect[i,1:(length(K)-1)]-best
  new_AIC_delta[i,] = AIC_vect[i,] - best2
}
```

```{r}
params_vector
```

```{r}
AIC_vect
```

```{r}
AIC_delta
```

```{r}
new_AIC_delta
```


```{r}

```



```{r}
lower_k = max(x)
# MLE RT ZETA
optgamma = function (ki) {
  mle_zeta_rt <- mle(minus_log_likelihood_rt_zeta,
                     start = list(gamma = 1.00001),
                     fixed = list(kmax = ki),
                     method = "L-BFGS-B",
                     lower = c(1.00001))
  return(attributes(summary(mle_zeta_rt))$coef[1])}

#mle_zeta_rt <- mle(optgamma,
#                   start = list(kmax = lower_k),
#                   method = "L-BFGS-B",
#                   lower = c(lower_k))

a = optim(fn = optgamma, par = list(kmax = max(x)), method = "L-BFGS-B", lower = c(max(x)))
```





